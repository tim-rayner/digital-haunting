<!-- public/display.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        background: #000;
        height: 100%;
      }
      video {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: none;
      }
      video.show {
        display: block;
      }

      /* Special styling for Halloween video */
      #halloween {
        object-fit: contain !important;
        object-position: center;
      }
    </style>
  </head>
  <body>
    <video
      id="devil-talks"
      autoplay
      muted
      playsinline
      src="/loops/devil-talks.mp4"
    ></video>
    <video
      id="ghost-girl"
      autoplay
      muted
      playsinline
      src="/loops/ghost-girl.mp4"
    ></video>
    <video
      id="realistic-zombie"
      autoplay
      muted
      playsinline
      src="/loops/realistic-zombie.mp4"
    ></video>
    <video
      id="ghost-wall"
      autoplay
      muted
      playsinline
      src="/loops/ghost-wall.mp4"
    ></video>
    <video
      id="zombie-power-cut"
      loop
      autoplay
      muted
      playsinline
      src="/loops/zombie-power-cut.mp4"
    ></video>
    <video
      id="zombie-walk"
      autoplay
      muted
      playsinline
      src="/loops/zombie-walk.mp4"
    ></video>
    <video id="halloween" muted playsinline src="/loops/halloween.mp4"></video>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const q = new URLSearchParams(location.search);
        const room = q.get('room') || 'HALLOWEEN';
        const socket = io({ transports: ['websocket'], reconnection: true, reconnectionDelayMax: 5000, timeout: 20000 });

        const vids = Object.fromEntries(Array.from(document.querySelectorAll('video[id]')).map(v => [v.id, v]));
        let currentTheme = null;

        function show(theme){
          if (!theme || !vids[theme]) return;
          Object.values(vids).forEach(v => v.classList.remove('show'));
          const v = vids[theme];
          v.classList.add('show');
          v.play?.().catch(()=>{});
          currentTheme = theme;
          console.log('[display] showing theme', theme);
        }

        // warm up
        Object.values(vids).forEach(v => v.play?.().catch(()=>{}));

        socket.on('connect', () => {
          console.log('[display] connected, joining', room);
          socket.emit('join', { room, role:'display' });
          // pull the latest state explicitly in case we missed any broadcast while reconnecting
          socket.emit('theme:get', room);
        });

        socket.on('theme:current', ({ theme }) => {
          console.log('[display] theme:current', theme);
          if (theme && theme !== currentTheme) show(theme);
        });

        socket.on('connect_error', err => console.warn('[display] connect_error', err));
        socket.on('disconnect', reason => console.warn('[display] disconnect', reason));
      });
    </script>
  </body>
</html>
