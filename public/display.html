<!-- public/display.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        background: #000;
        height: 100%;
      }
      video {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: none;
      }
      video.show {
        display: block;
      }

      /* Special styling for Halloween video */
      #halloween {
        object-fit: contain !important;
        object-position: center;
      }
    </style>
  </head>
  <body>
    <video
      id="devil-talks"
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/devil-talks.mp4"
    ></video>
    <video
      id="ghost-girl"
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/ghost-girl.mp4"
    ></video>
    <video
      id="realistic-zombie"
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/realistic-zombie.mp4"
    ></video>
    <video
      id="ghost-wall"
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/ghost-wall.mp4"
    ></video>
    <video
      id="zombie-power-cut"
      loop
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/zombie-power-cut.mp4"
    ></video>
    <video
      id="zombie-walk"
      autoplay
      muted
      playsinline
      preload="auto"
      src="/loops/zombie-walk.mp4"
    ></video>
    <video
      id="halloween"
      muted
      playsinline
      preload="auto"
      src="/loops/halloween.mp4"
    ></video>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const q = new URLSearchParams(location.search);
        const urlRoom = q.get("room");
        const room = urlRoom || localStorage.getItem("lastRoom") || "HALLOWEEN";
        localStorage.setItem("lastRoom", room);

        const socket = io({
          transports: ["websocket"],
          reconnection: true,
          reconnectionDelayMax: 5000,
          timeout: 20000,
        });

        const vids = Object.fromEntries(
          [...document.querySelectorAll("video[id]")].map((v) => [v.id, v])
        );
        Object.values(vids).forEach((v) => {
          v.preload = "auto";
          v.muted = true;
          v.play?.().catch(() => {});
        });

        let currentTheme = null;
        const DEFAULT_VIDEO = "zombie-power-cut"; // Default loop to revert to

        function show(theme) {
          if (!theme || !vids[theme]) return;

          // Remove all event listeners first to prevent duplicates
          Object.values(vids).forEach((v) => {
            v.removeEventListener("ended", handleVideoEnd);
          });

          Object.values(vids).forEach((v) => v.classList.remove("show"));
          const v = vids[theme];
          v.classList.add("show");

          // Add ended event listener to this video
          v.addEventListener("ended", handleVideoEnd, { once: true });

          setTimeout(() => v.play?.().catch(() => {}), 0); // nudge playback after paint
          currentTheme = theme;
          console.log("[display] showing", theme);
        }

        function handleVideoEnd() {
          console.log(
            "[display] video ended, reverting to default:",
            DEFAULT_VIDEO
          );
          show(DEFAULT_VIDEO);
        }

        // Local default: first video id
        const localDefault = Object.keys(vids)[0];
        if (localDefault) {
          show(localDefault);
        }

         socket.on("connect", () => {
           console.log("[display] connected; joining", room);
           socket.emit("join", { room, role: "display" });
           
           // Wait for join to complete, then request state
           setTimeout(() => {
             console.log("[display] requesting current state after connect");
             socket.emit("theme:get", room);
           }, 100);
         });

         // Add heartbeat to keep connection alive
         setInterval(() => {
           if (socket.connected) {
             socket.emit("ping");
           }
         }, 10000); // Every 10 seconds

        socket.on("theme:current", ({ theme }) => {
          console.log("[display] received theme:current", theme);
          if (theme && theme !== currentTheme) {
            console.log("[display] switching from", currentTheme, "to", theme);
            show(theme);
          }
        });

        // Enhanced error handling and reconnection
        socket.on("connect_error", (e) => {
          console.warn("[display] connect_error", e);
        });
        
        socket.on("disconnect", (r) => {
          console.warn("[display] disconnect", r);
        });

        socket.on("reconnect", (attemptNumber) => {
          console.log("[display] reconnected after", attemptNumber, "attempts");
          
          // Force state sync after reconnection
          setTimeout(() => {
            console.log("[display] forcing state sync after reconnect");
            socket.emit("theme:get", room);
          }, 500);
        });
      });
    </script>
  </body>
</html>
